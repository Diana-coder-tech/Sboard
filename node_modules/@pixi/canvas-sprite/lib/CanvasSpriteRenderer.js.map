{"version":3,"file":"CanvasSpriteRenderer.js","sources":["../src/CanvasSpriteRenderer.ts"],"sourcesContent":["import { canvasUtils } from '@pixi/canvas-renderer';\nimport { BLEND_MODES, extensions, ExtensionType, groupD8, Matrix, SCALE_MODES } from '@pixi/core';\n\nimport type { CanvasRenderer } from '@pixi/canvas-renderer';\nimport type { ExtensionMetadata } from '@pixi/core';\nimport type { Sprite } from '@pixi/sprite';\n\nconst canvasRenderWorldTransform = new Matrix();\n\n/**\n * Types that can be passed to drawImage\n * @typedef {HTMLImageElement|HTMLVideoElement|HTMLCanvasElement|ImageBitmap} ICanvasImageSource\n * @memberof PIXI\n */\n\n/*\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original PixiJS version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now\n * share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's CanvasSpriteRenderer:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/CanvasSpriteRenderer.java\n */\n\n/**\n * Renderer dedicated to drawing and batching sprites.\n * @class\n * @protected\n * @memberof PIXI\n */\nexport class CanvasSpriteRenderer\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        name: 'sprite',\n        type: ExtensionType.CanvasRendererPlugin,\n    };\n\n    /** A reference to the current renderer */\n    protected renderer: CanvasRenderer;\n\n    /** @param renderer - A reference to the current renderer */\n    constructor(renderer: CanvasRenderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * Renders the sprite object.\n     * @param sprite - the sprite to render when using this spritebatch\n     */\n    render(sprite: Sprite): void\n    {\n        const texture = sprite._texture;\n        const renderer = this.renderer;\n        const context = renderer.canvasContext.activeContext;\n        const activeResolution = renderer.canvasContext.activeResolution;\n\n        if (!texture.valid)\n        {\n            return;\n        }\n\n        const sourceWidth = texture._frame.width;\n        const sourceHeight = texture._frame.height;\n\n        let destWidth = texture._frame.width;\n        let destHeight = texture._frame.height;\n\n        if (texture.trim)\n        {\n            destWidth = texture.trim.width;\n            destHeight = texture.trim.height;\n        }\n\n        let wt = sprite.transform.worldTransform;\n        let dx = 0;\n        let dy = 0;\n\n        const source = texture.baseTexture.getDrawableSource();\n\n        if (texture.orig.width <= 0 || texture.orig.height <= 0 || !texture.valid || !source)\n        {\n            return;\n        }\n\n        renderer.canvasContext.setBlendMode(sprite.blendMode, true);\n\n        context.globalAlpha = sprite.worldAlpha;\n\n        // If smoothingEnabled is supported and we need to change the smoothing property for sprite texture\n        const smoothingEnabled = texture.baseTexture.scaleMode === SCALE_MODES.LINEAR;\n        const smoothProperty = renderer.canvasContext.smoothProperty;\n\n        if (smoothProperty\n            && context[smoothProperty] !== smoothingEnabled)\n        {\n            context[smoothProperty] = smoothingEnabled;\n        }\n\n        if (texture.trim)\n        {\n            dx = (texture.trim.width / 2) + texture.trim.x - (sprite.anchor.x * texture.orig.width);\n            dy = (texture.trim.height / 2) + texture.trim.y - (sprite.anchor.y * texture.orig.height);\n        }\n        else\n        {\n            dx = (0.5 - sprite.anchor.x) * texture.orig.width;\n            dy = (0.5 - sprite.anchor.y) * texture.orig.height;\n        }\n\n        if (texture.rotate)\n        {\n            wt.copyTo(canvasRenderWorldTransform);\n            wt = canvasRenderWorldTransform;\n            groupD8.matrixAppendRotationInv(wt, texture.rotate, dx, dy);\n            // the anchor has already been applied above, so lets set it to zero\n            dx = 0;\n            dy = 0;\n        }\n\n        dx -= destWidth / 2;\n        dy -= destHeight / 2;\n\n        renderer.canvasContext.setContextTransform(wt, sprite.roundPixels, 1);\n        // Allow for pixel rounding\n        if (sprite.roundPixels)\n        {\n            dx = dx | 0;\n            dy = dy | 0;\n        }\n\n        const resolution = texture.baseTexture.resolution;\n\n        const outerBlend = renderer.canvasContext._outerBlend;\n\n        if (outerBlend)\n        {\n            context.save();\n            context.beginPath();\n            context.rect(\n                dx * activeResolution,\n                dy * activeResolution,\n                destWidth * activeResolution,\n                destHeight * activeResolution\n            );\n            context.clip();\n        }\n\n        if (sprite.tint !== 0xFFFFFF)\n        {\n            if (sprite._cachedTint !== sprite.tintValue || sprite._tintedCanvas.tintId !== sprite._texture._updateID)\n            {\n                sprite._cachedTint = sprite.tintValue;\n\n                // TODO clean up caching - how to clean up the caches?\n                sprite._tintedCanvas = canvasUtils.getTintedCanvas(sprite, sprite.tintValue);\n            }\n\n            context.drawImage(\n                sprite._tintedCanvas,\n                0,\n                0,\n                Math.floor(sourceWidth * resolution),\n                Math.floor(sourceHeight * resolution),\n                Math.floor(dx * activeResolution),\n                Math.floor(dy * activeResolution),\n                Math.floor(destWidth * activeResolution),\n                Math.floor(destHeight * activeResolution)\n            );\n        }\n        else\n        {\n            context.drawImage(\n                source,\n                texture._frame.x * resolution,\n                texture._frame.y * resolution,\n                Math.floor(sourceWidth * resolution),\n                Math.floor(sourceHeight * resolution),\n                Math.floor(dx * activeResolution),\n                Math.floor(dy * activeResolution),\n                Math.floor(destWidth * activeResolution),\n                Math.floor(destHeight * activeResolution)\n            );\n        }\n\n        if (outerBlend)\n        {\n            context.restore();\n        }\n        // just in case, leaking outer blend here will be catastrophic!\n        renderer.canvasContext.setBlendMode(BLEND_MODES.NORMAL);\n    }\n\n    /** destroy the sprite object */\n    destroy(): void\n    {\n        this.renderer = null;\n    }\n}\n\nextensions.add(CanvasSpriteRenderer);\n"],"names":["Matrix","SCALE_MODES","groupD8","canvasUtils","BLEND_MODES","ExtensionType","extensions"],"mappings":"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"}