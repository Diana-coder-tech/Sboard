import { canvasUtils } from "@pixi/canvas-renderer";
import { Matrix, SCALE_MODES, groupD8, BLEND_MODES, ExtensionType, extensions } from "@pixi/core";
const canvasRenderWorldTransform = new Matrix();
class CanvasSpriteRenderer {
  /** @param renderer - A reference to the current renderer */
  constructor(renderer) {
    this.renderer = renderer;
  }
  /**
   * Renders the sprite object.
   * @param sprite - the sprite to render when using this spritebatch
   */
  render(sprite) {
    const texture = sprite._texture, renderer = this.renderer, context = renderer.canvasContext.activeContext, activeResolution = renderer.canvasContext.activeResolution;
    if (!texture.valid)
      return;
    const sourceWidth = texture._frame.width, sourceHeight = texture._frame.height;
    let destWidth = texture._frame.width, destHeight = texture._frame.height;
    texture.trim && (destWidth = texture.trim.width, destHeight = texture.trim.height);
    let wt = sprite.transform.worldTransform, dx = 0, dy = 0;
    const source = texture.baseTexture.getDrawableSource();
    if (texture.orig.width <= 0 || texture.orig.height <= 0 || !texture.valid || !source)
      return;
    renderer.canvasContext.setBlendMode(sprite.blendMode, !0), context.globalAlpha = sprite.worldAlpha;
    const smoothingEnabled = texture.baseTexture.scaleMode === SCALE_MODES.LINEAR, smoothProperty = renderer.canvasContext.smoothProperty;
    smoothProperty && context[smoothProperty] !== smoothingEnabled && (context[smoothProperty] = smoothingEnabled), texture.trim ? (dx = texture.trim.width / 2 + texture.trim.x - sprite.anchor.x * texture.orig.width, dy = texture.trim.height / 2 + texture.trim.y - sprite.anchor.y * texture.orig.height) : (dx = (0.5 - sprite.anchor.x) * texture.orig.width, dy = (0.5 - sprite.anchor.y) * texture.orig.height), texture.rotate && (wt.copyTo(canvasRenderWorldTransform), wt = canvasRenderWorldTransform, groupD8.matrixAppendRotationInv(wt, texture.rotate, dx, dy), dx = 0, dy = 0), dx -= destWidth / 2, dy -= destHeight / 2, renderer.canvasContext.setContextTransform(wt, sprite.roundPixels, 1), sprite.roundPixels && (dx = dx | 0, dy = dy | 0);
    const resolution = texture.baseTexture.resolution, outerBlend = renderer.canvasContext._outerBlend;
    outerBlend && (context.save(), context.beginPath(), context.rect(
      dx * activeResolution,
      dy * activeResolution,
      destWidth * activeResolution,
      destHeight * activeResolution
    ), context.clip()), sprite.tint !== 16777215 ? ((sprite._cachedTint !== sprite.tintValue || sprite._tintedCanvas.tintId !== sprite._texture._updateID) && (sprite._cachedTint = sprite.tintValue, sprite._tintedCanvas = canvasUtils.getTintedCanvas(sprite, sprite.tintValue)), context.drawImage(
      sprite._tintedCanvas,
      0,
      0,
      Math.floor(sourceWidth * resolution),
      Math.floor(sourceHeight * resolution),
      Math.floor(dx * activeResolution),
      Math.floor(dy * activeResolution),
      Math.floor(destWidth * activeResolution),
      Math.floor(destHeight * activeResolution)
    )) : context.drawImage(
      source,
      texture._frame.x * resolution,
      texture._frame.y * resolution,
      Math.floor(sourceWidth * resolution),
      Math.floor(sourceHeight * resolution),
      Math.floor(dx * activeResolution),
      Math.floor(dy * activeResolution),
      Math.floor(destWidth * activeResolution),
      Math.floor(destHeight * activeResolution)
    ), outerBlend && context.restore(), renderer.canvasContext.setBlendMode(BLEND_MODES.NORMAL);
  }
  /** destroy the sprite object */
  destroy() {
    this.renderer = null;
  }
}
CanvasSpriteRenderer.extension = {
  name: "sprite",
  type: ExtensionType.CanvasRendererPlugin
};
extensions.add(CanvasSpriteRenderer);
export {
  CanvasSpriteRenderer
};
//# sourceMappingURL=CanvasSpriteRenderer.mjs.map
