"use strict";
var canvasRenderer = require("@pixi/canvas-renderer"), core = require("@pixi/core");
class CanvasMeshRenderer {
  /** @param renderer - A reference to the current renderer */
  constructor(renderer) {
    this.renderer = renderer;
  }
  /**
   * Renders the Mesh
   * @param mesh - the Mesh to render
   */
  render(mesh) {
    const renderer = this.renderer, transform = mesh.worldTransform;
    renderer.canvasContext.activeContext.globalAlpha = mesh.worldAlpha, renderer.canvasContext.setBlendMode(mesh.blendMode), renderer.canvasContext.setContextTransform(transform, mesh.roundPixels), mesh.drawMode !== core.DRAW_MODES.TRIANGLES ? this._renderTriangleMesh(mesh) : this._renderTriangles(mesh);
  }
  /**
   * Draws the object in Triangle Mesh mode
   * @private
   * @param mesh - the Mesh to render
   */
  _renderTriangleMesh(mesh) {
    const length = mesh.geometry.buffers[0].data.length;
    for (let i = 0; i < length - 2; i++) {
      const index = i * 2;
      this._renderDrawTriangle(mesh, index, index + 2, index + 4);
    }
  }
  /**
   * Draws the object in triangle mode using canvas
   * @private
   * @param mesh - the current mesh
   */
  _renderTriangles(mesh) {
    const indices = mesh.geometry.getIndex().data, length = indices.length;
    for (let i = 0; i < length; i += 3) {
      const index0 = indices[i] * 2, index1 = indices[i + 1] * 2, index2 = indices[i + 2] * 2;
      this._renderDrawTriangle(mesh, index0, index1, index2);
    }
  }
  /**
   * Draws one of the triangles that from the Mesh
   * @private
   * @param mesh - the current mesh
   * @param index0 - the index of the first vertex
   * @param index1 - the index of the second vertex
   * @param index2 - the index of the third vertex
   */
  _renderDrawTriangle(mesh, index0, index1, index2) {
    const context = this.renderer.canvasContext.activeContext, vertices = mesh.geometry.buffers[0].data, { uvs, texture } = mesh;
    if (!texture.valid)
      return;
    const isTinted = mesh.tintValue !== 16777215, base = texture.baseTexture, textureWidth = base.width, textureHeight = base.height;
    mesh._cachedTexture && mesh._cachedTexture.baseTexture !== base && (mesh._cachedTint = 16777215, mesh._cachedTexture?.destroy(), mesh._cachedTexture = null, mesh._tintedCanvas = null), isTinted && mesh._cachedTint !== mesh.tintValue && (mesh._cachedTint = mesh.tintValue, mesh._cachedTexture = mesh._cachedTexture || new core.Texture(base), mesh._tintedCanvas = canvasRenderer.canvasUtils.getTintedCanvas(
      { texture: mesh._cachedTexture },
      mesh.tintValue
    ));
    const textureSource = isTinted ? mesh._tintedCanvas : base.getDrawableSource(), u0 = uvs[index0] * base.width, u1 = uvs[index1] * base.width, u2 = uvs[index2] * base.width, v0 = uvs[index0 + 1] * base.height, v1 = uvs[index1 + 1] * base.height, v2 = uvs[index2 + 1] * base.height;
    let x0 = vertices[index0], x1 = vertices[index1], x2 = vertices[index2], y0 = vertices[index0 + 1], y1 = vertices[index1 + 1], y2 = vertices[index2 + 1];
    const screenPadding = mesh.canvasPadding / this.renderer.canvasContext.activeResolution;
    if (screenPadding > 0) {
      const { a, b, c, d } = mesh.worldTransform, centerX = (x0 + x1 + x2) / 3, centerY = (y0 + y1 + y2) / 3;
      let normX = x0 - centerX, normY = y0 - centerY, screenX = a * normX + c * normY, screenY = b * normX + d * normY, screenDist = Math.sqrt(screenX * screenX + screenY * screenY), paddingFactor = 1 + screenPadding / screenDist;
      x0 = centerX + normX * paddingFactor, y0 = centerY + normY * paddingFactor, normX = x1 - centerX, normY = y1 - centerY, screenX = a * normX + c * normY, screenY = b * normX + d * normY, screenDist = Math.sqrt(screenX * screenX + screenY * screenY), paddingFactor = 1 + screenPadding / screenDist, x1 = centerX + normX * paddingFactor, y1 = centerY + normY * paddingFactor, normX = x2 - centerX, normY = y2 - centerY, screenX = a * normX + c * normY, screenY = b * normX + d * normY, screenDist = Math.sqrt(screenX * screenX + screenY * screenY), paddingFactor = 1 + screenPadding / screenDist, x2 = centerX + normX * paddingFactor, y2 = centerY + normY * paddingFactor;
    }
    context.save(), context.beginPath(), context.moveTo(x0, y0), context.lineTo(x1, y1), context.lineTo(x2, y2), context.closePath(), context.clip();
    const delta = u0 * v1 + v0 * u2 + u1 * v2 - v1 * u2 - v0 * u1 - u0 * v2, deltaA = x0 * v1 + v0 * x2 + x1 * v2 - v1 * x2 - v0 * x1 - x0 * v2, deltaB = u0 * x1 + x0 * u2 + u1 * x2 - x1 * u2 - x0 * u1 - u0 * x2, deltaC = u0 * v1 * x2 + v0 * x1 * u2 + x0 * u1 * v2 - x0 * v1 * u2 - v0 * u1 * x2 - u0 * x1 * v2, deltaD = y0 * v1 + v0 * y2 + y1 * v2 - v1 * y2 - v0 * y1 - y0 * v2, deltaE = u0 * y1 + y0 * u2 + u1 * y2 - y1 * u2 - y0 * u1 - u0 * y2, deltaF = u0 * v1 * y2 + v0 * y1 * u2 + y0 * u1 * v2 - y0 * v1 * u2 - v0 * u1 * y2 - u0 * y1 * v2;
    context.transform(
      deltaA / delta,
      deltaD / delta,
      deltaB / delta,
      deltaE / delta,
      deltaC / delta,
      deltaF / delta
    ), context.drawImage(
      textureSource,
      0,
      0,
      textureWidth * base.resolution,
      textureHeight * base.resolution,
      0,
      0,
      textureWidth,
      textureHeight
    ), context.restore(), this.renderer.canvasContext.invalidateBlendMode();
  }
  /**
   * Renders a flat Mesh
   * @private
   * @param mesh - The Mesh to render
   */
  renderMeshFlat(mesh) {
    const context = this.renderer.canvasContext.activeContext, vertices = mesh.geometry.getBuffer("aVertexPosition").data, length = vertices.length / 2;
    context.beginPath();
    for (let i = 1; i < length - 2; ++i) {
      const index = i * 2, x0 = vertices[index], y0 = vertices[index + 1], x1 = vertices[index + 2], y1 = vertices[index + 3], x2 = vertices[index + 4], y2 = vertices[index + 5];
      context.moveTo(x0, y0), context.lineTo(x1, y1), context.lineTo(x2, y2);
    }
    context.fillStyle = "#FF0000", context.fill(), context.closePath();
  }
  /** destroy the renderer */
  destroy() {
    this.renderer = null;
  }
}
CanvasMeshRenderer.extension = {
  name: "mesh",
  type: core.ExtensionType.CanvasRendererPlugin
};
core.extensions.add(CanvasMeshRenderer);
exports.CanvasMeshRenderer = CanvasMeshRenderer;
//# sourceMappingURL=CanvasMeshRenderer.js.map
