{"version":3,"file":"TilingSprite.mjs","sources":["../src/TilingSprite.ts"],"sourcesContent":["import { canvasUtils } from '@pixi/canvas-renderer';\nimport { Matrix, Point, utils } from '@pixi/core';\nimport { TilingSprite } from '@pixi/sprite-tiling';\n\nimport type { CanvasRenderer } from '@pixi/canvas-renderer';\n\nconst worldMatrix = new Matrix();\nconst patternMatrix = new Matrix();\nconst patternRect = [new Point(), new Point(), new Point(), new Point()];\n\n/**\n * Renders the object using the Canvas renderer\n * @protected\n * @function _renderCanvas\n * @memberof PIXI.TilingSprite#\n * @param {PIXI.CanvasRenderer} renderer - a reference to the canvas renderer\n */\nTilingSprite.prototype._renderCanvas = function _renderCanvas(renderer: CanvasRenderer): void\n{\n    const texture = this._texture;\n\n    if (!texture.baseTexture.valid)\n    {\n        return;\n    }\n\n    const context = renderer.canvasContext.activeContext;\n    const transform = this.worldTransform;\n    const baseTexture = texture.baseTexture;\n    const source = baseTexture.getDrawableSource();\n    const baseTextureResolution = baseTexture.resolution;\n\n    // create a nice shiny pattern!\n    if (this._textureID !== this._texture._updateID || this._cachedTint !== this.tintValue)\n    {\n        this._textureID = this._texture._updateID;\n        // cut an object from a spritesheet..\n        const tempCanvas = new utils.CanvasRenderTarget(texture._frame.width,\n            texture._frame.height,\n            baseTextureResolution);\n\n        // Tint the tiling sprite\n        if (this.tintValue !== 0xFFFFFF)\n        {\n            this._tintedCanvas = canvasUtils.getTintedCanvas(this, this.tintValue);\n            tempCanvas.context.drawImage(this._tintedCanvas, 0, 0);\n        }\n        else\n        {\n            tempCanvas.context.drawImage(source,\n                -texture._frame.x * baseTextureResolution, -texture._frame.y * baseTextureResolution);\n        }\n        this._cachedTint = this.tintValue;\n        this._canvasPattern = tempCanvas.context.createPattern(tempCanvas.canvas, 'repeat');\n    }\n\n    // set context state..\n    context.globalAlpha = this.worldAlpha;\n    renderer.canvasContext.setBlendMode(this.blendMode);\n\n    this.tileTransform.updateLocalTransform();\n    const lt = this.tileTransform.localTransform;\n    const W = this._width;\n    const H = this._height;\n\n    /*\n     * # Implementation Notes\n     *\n     * The tiling transform is not simply a transform on the tiling sprite's local space. If that\n     * were, the bounds of the tiling sprite would change. Rather the tile transform is a transform\n     * on the \"pattern\" coordinates each vertex is assigned.\n     *\n     * To implement the `tileTransform`, we issue drawing commands in the pattern's own space, which\n     * is defined as:\n     *\n     * Pattern_Space = Local_Space x inverse(tileTransform)\n     *\n     * In other words,\n     * Local_Space = Pattern_Space x tileTransform\n     *\n     * We draw the pattern in pattern space, because the space we draw in defines the pattern's coordinates.\n     * In other words, the pattern will always \"originate\" from (0, 0) in the space we draw in.\n     *\n     * This technique is equivalent to drawing a pattern texture, and then finding a quadrilateral that becomes\n     * the tiling sprite's local bounds under the tileTransform and mapping that onto the screen.\n     *\n     * ## uvRespectAnchor\n     *\n     * The preceding paragraph discusses the case without considering `uvRespectAnchor`. The `uvRespectAnchor` flags\n     * where the origin of the pattern space is. Assuming the tileTransform includes no translation, without\n     * loss of generality: If uvRespectAnchor = true, then\n     *\n     * Local Space (0, 0) <--> Pattern Space (0, 0) (where <--> means \"maps to\")\n     *\n     * Here the mapping is provided by trivially by the tileTransform (note tileTransform includes no translation. That\n     * means the invariant under all other transforms are the origins)\n     *\n     * Otherwise,\n     *\n     * Local Space (-localBounds.x, -localBounds.y) <--> Pattern Space (0, 0)\n     *\n     * Here the mapping is provided by the tileTransform PLUS some \"shift\". This shift is done POST-tileTransform. The shift\n     * is equal to the position of the top-left corner of the tiling sprite in its local space.\n     *\n     * Hence,\n     *\n     * Local_Space = Pattern_Space x tileTransform x shiftTransform\n     */\n\n    // worldMatrix is used to convert from pattern space to world space.\n    //\n    // worldMatrix = tileTransform x shiftTransform x worldTransform\n    //             = patternMatrix x worldTransform\n    worldMatrix.identity();\n\n    // patternMatrix is used to convert from pattern space to local space. The drawing commands are issued in pattern space\n    // and this matrix is used to inverse-map the local space vertices into it.\n    //\n    // patternMatrix = tileTransform x shiftTransform\n    patternMatrix.copyFrom(lt);\n\n    // Apply shiftTransform into patternMatrix. See $1.1\n    if (!this.uvRespectAnchor)\n    {\n        patternMatrix.translate(-this.anchor.x * W, -this.anchor.y * H);\n    }\n\n    patternMatrix.scale(1 / baseTextureResolution, 1 / baseTextureResolution);\n    worldMatrix.prepend(patternMatrix);\n    worldMatrix.prepend(transform);\n\n    renderer.canvasContext.setContextTransform(worldMatrix);\n\n    // Fill the pattern!\n    context.fillStyle = this._canvasPattern;\n\n    // The position in local space we are drawing the rectangle: (lx, ly, lx + W, ly + H)\n    const lx = this.anchor.x * -W;\n    const ly = this.anchor.y * -H;\n\n    // Set pattern rect in local space first.\n    patternRect[0].set(lx, ly);\n    patternRect[1].set(lx + W, ly);\n    patternRect[2].set(lx + W, ly + H);\n    patternRect[3].set(lx, ly + H);\n\n    // Map patternRect into pattern space.\n    for (let i = 0; i < 4; i++)\n    {\n        patternMatrix.applyInverse(patternRect[i], patternRect[i]);\n    }\n\n    /*\n     * # Note about verification of theory\n     *\n     * As discussed in the implementation notes, you can verify that `patternRect[0]` will always be (0, 0) in case of\n     * `uvRespectAnchor` false and tileTransform having no translation. Indeed, because the pattern origin should map\n     * to the top-left corner of the tiling sprite in its local space.\n     */\n\n    context.beginPath();\n    context.moveTo(patternRect[0].x, patternRect[0].y);\n\n    for (let i = 1; i < 4; i++)\n    {\n        context.lineTo(patternRect[i].x, patternRect[i].y);\n    }\n\n    context.closePath();\n    context.fill();\n};\n"],"names":[],"mappings":";;;AAMA,MAAM,cAAc,IAAI,OAAO,GACzB,gBAAgB,IAAI,UACpB,cAAc,CAAC,IAAI,MAAM,GAAG,IAAI,SAAS,IAAI,MAAM,GAAG,IAAI,MAAA,CAAO;AASvE,aAAa,UAAU,gBAAgB,SAAuB,UAC9D;AACI,QAAM,UAAU,KAAK;AAEjB,MAAA,CAAC,QAAQ,YAAY;AAErB;AAGJ,QAAM,UAAU,SAAS,cAAc,eACjC,YAAY,KAAK,gBACjB,cAAc,QAAQ,aACtB,SAAS,YAAY,kBAAkB,GACvC,wBAAwB,YAAY;AAGtC,MAAA,KAAK,eAAe,KAAK,SAAS,aAAa,KAAK,gBAAgB,KAAK,WAC7E;AACS,SAAA,aAAa,KAAK,SAAS;AAE1B,UAAA,aAAa,IAAI,MAAM;AAAA,MAAmB,QAAQ,OAAO;AAAA,MAC3D,QAAQ,OAAO;AAAA,MACf;AAAA,IAAA;AAGA,SAAK,cAAc,YAEnB,KAAK,gBAAgB,YAAY,gBAAgB,MAAM,KAAK,SAAS,GACrE,WAAW,QAAQ,UAAU,KAAK,eAAe,GAAG,CAAC,KAIrD,WAAW,QAAQ;AAAA,MAAU;AAAA,MACzB,CAAC,QAAQ,OAAO,IAAI;AAAA,MAAuB,CAAC,QAAQ,OAAO,IAAI;AAAA,IAEvE,GAAA,KAAK,cAAc,KAAK,WACxB,KAAK,iBAAiB,WAAW,QAAQ,cAAc,WAAW,QAAQ,QAAQ;AAAA,EACtF;AAGQ,UAAA,cAAc,KAAK,YAC3B,SAAS,cAAc,aAAa,KAAK,SAAS,GAElD,KAAK,cAAc,qBAAqB;AAClC,QAAA,KAAK,KAAK,cAAc,gBACxB,IAAI,KAAK,QACT,IAAI,KAAK;AAkDf,cAAY,SAMZ,GAAA,cAAc,SAAS,EAAE,GAGpB,KAAK,mBAEN,cAAc,UAAU,CAAC,KAAK,OAAO,IAAI,GAAG,CAAC,KAAK,OAAO,IAAI,CAAC,GAGlE,cAAc,MAAM,IAAI,uBAAuB,IAAI,qBAAqB,GACxE,YAAY,QAAQ,aAAa,GACjC,YAAY,QAAQ,SAAS,GAE7B,SAAS,cAAc,oBAAoB,WAAW,GAGtD,QAAQ,YAAY,KAAK;AAGnB,QAAA,KAAK,KAAK,OAAO,IAAI,CAAC,GACtB,KAAK,KAAK,OAAO,IAAI,CAAC;AAG5B,cAAY,CAAC,EAAE,IAAI,IAAI,EAAE,GACzB,YAAY,CAAC,EAAE,IAAI,KAAK,GAAG,EAAE,GAC7B,YAAY,CAAC,EAAE,IAAI,KAAK,GAAG,KAAK,CAAC,GACjC,YAAY,CAAC,EAAE,IAAI,IAAI,KAAK,CAAC;AAGpB,WAAA,IAAI,GAAG,IAAI,GAAG;AAEnB,kBAAc,aAAa,YAAY,CAAC,GAAG,YAAY,CAAC,CAAC;AAWrD,UAAA,UAAA,GACR,QAAQ,OAAO,YAAY,CAAC,EAAE,GAAG,YAAY,CAAC,EAAE,CAAC;AAExC,WAAA,IAAI,GAAG,IAAI,GAAG;AAEX,YAAA,OAAO,YAAY,CAAC,EAAE,GAAG,YAAY,CAAC,EAAE,CAAC;AAG7C,UAAA,UAAA,GACR,QAAQ,KAAK;AACjB;"}