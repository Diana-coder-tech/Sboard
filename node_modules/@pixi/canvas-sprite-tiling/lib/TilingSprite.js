"use strict";
var canvasRenderer = require("@pixi/canvas-renderer"), core = require("@pixi/core"), spriteTiling = require("@pixi/sprite-tiling");
const worldMatrix = new core.Matrix(), patternMatrix = new core.Matrix(), patternRect = [new core.Point(), new core.Point(), new core.Point(), new core.Point()];
spriteTiling.TilingSprite.prototype._renderCanvas = function(renderer) {
  const texture = this._texture;
  if (!texture.baseTexture.valid)
    return;
  const context = renderer.canvasContext.activeContext, transform = this.worldTransform, baseTexture = texture.baseTexture, source = baseTexture.getDrawableSource(), baseTextureResolution = baseTexture.resolution;
  if (this._textureID !== this._texture._updateID || this._cachedTint !== this.tintValue) {
    this._textureID = this._texture._updateID;
    const tempCanvas = new core.utils.CanvasRenderTarget(
      texture._frame.width,
      texture._frame.height,
      baseTextureResolution
    );
    this.tintValue !== 16777215 ? (this._tintedCanvas = canvasRenderer.canvasUtils.getTintedCanvas(this, this.tintValue), tempCanvas.context.drawImage(this._tintedCanvas, 0, 0)) : tempCanvas.context.drawImage(
      source,
      -texture._frame.x * baseTextureResolution,
      -texture._frame.y * baseTextureResolution
    ), this._cachedTint = this.tintValue, this._canvasPattern = tempCanvas.context.createPattern(tempCanvas.canvas, "repeat");
  }
  context.globalAlpha = this.worldAlpha, renderer.canvasContext.setBlendMode(this.blendMode), this.tileTransform.updateLocalTransform();
  const lt = this.tileTransform.localTransform, W = this._width, H = this._height;
  worldMatrix.identity(), patternMatrix.copyFrom(lt), this.uvRespectAnchor || patternMatrix.translate(-this.anchor.x * W, -this.anchor.y * H), patternMatrix.scale(1 / baseTextureResolution, 1 / baseTextureResolution), worldMatrix.prepend(patternMatrix), worldMatrix.prepend(transform), renderer.canvasContext.setContextTransform(worldMatrix), context.fillStyle = this._canvasPattern;
  const lx = this.anchor.x * -W, ly = this.anchor.y * -H;
  patternRect[0].set(lx, ly), patternRect[1].set(lx + W, ly), patternRect[2].set(lx + W, ly + H), patternRect[3].set(lx, ly + H);
  for (let i = 0; i < 4; i++)
    patternMatrix.applyInverse(patternRect[i], patternRect[i]);
  context.beginPath(), context.moveTo(patternRect[0].x, patternRect[0].y);
  for (let i = 1; i < 4; i++)
    context.lineTo(patternRect[i].x, patternRect[i].y);
  context.closePath(), context.fill();
};
//# sourceMappingURL=TilingSprite.js.map
