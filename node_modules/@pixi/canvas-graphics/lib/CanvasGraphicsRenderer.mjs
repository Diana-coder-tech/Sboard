import { canvasUtils } from "@pixi/canvas-renderer";
import { Matrix, Texture, Color, SHAPES, ExtensionType, extensions } from "@pixi/core";
import { PolygonUtils } from "./utils/PolygonUtils.mjs";
class CanvasGraphicsRenderer {
  /**
   * @param renderer - A reference to the current renderer.
   */
  constructor(renderer) {
    this._svgMatrix = null, this._tempMatrix = new Matrix(), this.renderer = renderer;
  }
  /**
   * calculates fill/stroke style for canvas
   * @private
   * @param style - A graphics {@link PIXI.FILL_STYLE} where if `texture` is specified then a tinted CanvasPattern
   * will be used for the fill.stroke
   * @param tint - color to set the fill/stroke too.
   */
  _calcCanvasStyle(style, tint) {
    let res;
    return style.texture && style.texture.baseTexture !== Texture.WHITE.baseTexture ? style.texture.valid ? (res = canvasUtils.getTintedPattern(style.texture, tint), this.setPatternTransform(res, style.matrix || Matrix.IDENTITY)) : res = "#808080" : res = `#${`00000${(tint | 0).toString(16)}`.slice(-6)}`, res;
  }
  /**
   * Renders a Graphics object to a canvas.
   * @param graphics - the actual graphics object to render
   */
  render(graphics) {
    const renderer = this.renderer, context = renderer.canvasContext.activeContext, worldAlpha = graphics.worldAlpha, transform = graphics.transform.worldTransform;
    renderer.canvasContext.setContextTransform(transform), renderer.canvasContext.setBlendMode(graphics.blendMode);
    const graphicsData = graphics.geometry.graphicsData;
    let contextFillStyle, contextStrokeStyle;
    const tint = Color.shared.setValue(graphics.tint).toArray();
    for (let i = 0; i < graphicsData.length; i++) {
      const data = graphicsData[i], shape = data.shape, fillStyle = data.fillStyle, lineStyle = data.lineStyle, fillColor = data.fillStyle.color | 0, lineColor = data.lineStyle.color | 0;
      if (data.matrix && renderer.canvasContext.setContextTransform(transform.copyTo(this._tempMatrix).append(data.matrix)), fillStyle.visible && (contextFillStyle = this._calcCanvasStyle(
        fillStyle,
        Color.shared.setValue(fillColor).multiply(tint).toNumber()
      )), lineStyle.visible && (contextStrokeStyle = this._calcCanvasStyle(
        lineStyle,
        Color.shared.setValue(lineColor).multiply(tint).toNumber()
      )), context.lineWidth = lineStyle.width, context.lineCap = lineStyle.cap, context.lineJoin = lineStyle.join, context.miterLimit = lineStyle.miterLimit, data.type === SHAPES.POLY) {
        context.beginPath();
        const tempShape = shape;
        let points = tempShape.points;
        const holes = data.holes;
        let outerArea, innerArea, px, py, holesDirection;
        context.moveTo(points[0], points[1]);
        for (let j = 2; j < points.length; j += 2)
          context.lineTo(points[j], points[j + 1]);
        if (tempShape.closeStroke && context.closePath(), holes.length > 0) {
          holesDirection = [], outerArea = 0, px = points[0], py = points[1];
          for (let j = 2; j + 2 < points.length; j += 2)
            outerArea += (points[j] - px) * (points[j + 3] - py) - (points[j + 2] - px) * (points[j + 1] - py);
          for (let k = 0; k < holes.length; k++)
            if (points = holes[k].shape.points, !!points) {
              innerArea = 0, px = points[0], py = points[1];
              for (let j = 2; j + 2 < points.length; j += 2)
                innerArea += (points[j] - px) * (points[j + 3] - py) - (points[j + 2] - px) * (points[j + 1] - py);
              if (innerArea * outerArea < 0) {
                context.moveTo(points[0], points[1]);
                for (let j = 2; j < points.length; j += 2)
                  context.lineTo(points[j], points[j + 1]);
              } else {
                context.moveTo(points[points.length - 2], points[points.length - 1]);
                for (let j = points.length - 4; j >= 0; j -= 2)
                  context.lineTo(points[j], points[j + 1]);
              }
              holes[k].shape.closeStroke && context.closePath(), holesDirection[k] = innerArea * outerArea < 0;
            }
        }
        fillStyle.visible && (context.globalAlpha = fillStyle.alpha * worldAlpha, context.fillStyle = contextFillStyle, context.fill()), lineStyle.visible && this.paintPolygonStroke(
          tempShape,
          lineStyle,
          contextStrokeStyle,
          holes,
          holesDirection,
          worldAlpha,
          context
        );
      } else if (data.type === SHAPES.RECT) {
        const tempShape = shape;
        if (fillStyle.visible && (context.globalAlpha = fillStyle.alpha * worldAlpha, context.fillStyle = contextFillStyle, context.fillRect(tempShape.x, tempShape.y, tempShape.width, tempShape.height)), lineStyle.visible) {
          const alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment)), width = tempShape.width + 2 * alignmentOffset, height = tempShape.height + 2 * alignmentOffset;
          context.globalAlpha = lineStyle.alpha * worldAlpha, context.strokeStyle = contextStrokeStyle, context.strokeRect(tempShape.x - alignmentOffset, tempShape.y - alignmentOffset, width, height);
        }
      } else if (data.type === SHAPES.CIRC) {
        const tempShape = shape;
        if (context.beginPath(), context.arc(tempShape.x, tempShape.y, tempShape.radius, 0, 2 * Math.PI), context.closePath(), fillStyle.visible && (context.globalAlpha = fillStyle.alpha * worldAlpha, context.fillStyle = contextFillStyle, context.fill()), lineStyle.visible) {
          if (lineStyle.alignment !== 0.5) {
            const alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));
            context.beginPath(), context.arc(tempShape.x, tempShape.y, tempShape.radius + alignmentOffset, 0, 2 * Math.PI), context.closePath();
          }
          context.globalAlpha = lineStyle.alpha * worldAlpha, context.strokeStyle = contextStrokeStyle, context.stroke();
        }
      } else if (data.type === SHAPES.ELIP) {
        const tempShape = shape, drawShapeOverStroke = lineStyle.alignment === 1;
        if (drawShapeOverStroke || this.paintEllipse(tempShape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context), lineStyle.visible) {
          if (lineStyle.alignment !== 0.5) {
            const kappa = 0.5522848, alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment)), sW = (tempShape.width + alignmentOffset) * 2, sH = (tempShape.height + alignmentOffset) * 2, sX = tempShape.x - sW / 2, sY = tempShape.y - sH / 2, sOx = sW / 2 * kappa, sOy = sH / 2 * kappa, sXe = sX + sW, sYe = sY + sH, sXm = sX + sW / 2, sYm = sY + sH / 2;
            context.beginPath(), context.moveTo(sX, sYm), context.bezierCurveTo(sX, sYm - sOy, sXm - sOx, sY, sXm, sY), context.bezierCurveTo(sXm + sOx, sY, sXe, sYm - sOy, sXe, sYm), context.bezierCurveTo(sXe, sYm + sOy, sXm + sOx, sYe, sXm, sYe), context.bezierCurveTo(sXm - sOx, sYe, sX, sYm + sOy, sX, sYm), context.closePath();
          }
          context.globalAlpha = lineStyle.alpha * worldAlpha, context.strokeStyle = contextStrokeStyle, context.stroke();
        }
        drawShapeOverStroke && this.paintEllipse(tempShape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context);
      } else if (data.type === SHAPES.RREC) {
        const tempShape = shape, drawShapeOverStroke = lineStyle.alignment === 1;
        if (drawShapeOverStroke || this.paintRoundedRectangle(tempShape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context), lineStyle.visible) {
          if (lineStyle.alignment !== 0.5) {
            const width = tempShape.width, height = tempShape.height, alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment)), sRx = tempShape.x - alignmentOffset, sRy = tempShape.y - alignmentOffset, sWidth = tempShape.width + 2 * alignmentOffset, sHeight = tempShape.height + 2 * alignmentOffset, radiusOffset = alignmentOffset * (lineStyle.alignment >= 1 ? Math.min(sWidth / width, sHeight / height) : Math.min(width / sWidth, height / sHeight));
            let sRadius = tempShape.radius + radiusOffset;
            const sMaxRadius = Math.min(sWidth, sHeight) / 2;
            sRadius = sRadius > sMaxRadius ? sMaxRadius : sRadius, context.beginPath(), context.moveTo(sRx, sRy + sRadius), context.lineTo(sRx, sRy + sHeight - sRadius), context.quadraticCurveTo(sRx, sRy + sHeight, sRx + sRadius, sRy + sHeight), context.lineTo(sRx + sWidth - sRadius, sRy + sHeight), context.quadraticCurveTo(sRx + sWidth, sRy + sHeight, sRx + sWidth, sRy + sHeight - sRadius), context.lineTo(sRx + sWidth, sRy + sRadius), context.quadraticCurveTo(sRx + sWidth, sRy, sRx + sWidth - sRadius, sRy), context.lineTo(sRx + sRadius, sRy), context.quadraticCurveTo(sRx, sRy, sRx, sRy + sRadius), context.closePath();
          }
          context.globalAlpha = lineStyle.alpha * worldAlpha, context.strokeStyle = contextStrokeStyle, context.stroke();
        }
        drawShapeOverStroke && this.paintRoundedRectangle(tempShape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context);
      }
    }
  }
  /**
   * Paint stroke for polygon and holes
   * @private
   * @param shape - Shape to be drawn
   * @param lineStyle - Line style for the shape
   * @param contextStrokeStyle - The strokeStyle for the canvas context
   * @param holes - Holes to be added to the shape
   * @param holesDirection -
   * @param worldAlpha - The multiplied alpha of the displayObject
   * @param context - The canvas context
   */
  paintPolygonStroke(shape, lineStyle, contextStrokeStyle, holes, holesDirection, worldAlpha, context) {
    if (lineStyle.alignment !== 0.5) {
      const alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));
      let offsetPoints = PolygonUtils.offsetPolygon(shape.points, alignmentOffset), points;
      context.beginPath(), context.moveTo(offsetPoints[0], offsetPoints[1]);
      for (let j = 2; j < offsetPoints.length; j += 2)
        context.lineTo(offsetPoints[j], offsetPoints[j + 1]);
      shape.closeStroke && context.closePath();
      for (let k = 0; k < holes.length; k++) {
        if (points = holes[k].shape.points, offsetPoints = PolygonUtils.offsetPolygon(points, alignmentOffset), holesDirection[k]) {
          context.moveTo(offsetPoints[0], offsetPoints[1]);
          for (let j = 2; j < offsetPoints.length; j += 2)
            context.lineTo(offsetPoints[j], offsetPoints[j + 1]);
        } else {
          context.moveTo(offsetPoints[offsetPoints.length - 2], offsetPoints[offsetPoints.length - 1]);
          for (let j = offsetPoints.length - 4; j >= 0; j -= 2)
            context.lineTo(offsetPoints[j], offsetPoints[j + 1]);
        }
        holes[k].shape.closeStroke && context.closePath();
      }
    }
    context.globalAlpha = lineStyle.alpha * worldAlpha, context.strokeStyle = contextStrokeStyle, context.stroke();
  }
  /**
   * Paint Ellipse
   * @private
   * @param shape - Shape to be drawn
   * @param fillStyle - Fill for the shape
   * @param lineStyle - Line style for the shape
   * @param contextFillStyle - The canvas context fill style
   * @param worldAlpha - The multiplied alpha of the displayObject
   * @param context - The canvas context
   */
  paintEllipse(shape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context) {
    const w = shape.width * 2, h = shape.height * 2, x = shape.x - w / 2, y = shape.y - h / 2, kappa = 0.5522848, ox = w / 2 * kappa, oy = h / 2 * kappa, xe = x + w, ye = y + h, xm = x + w / 2, ym = y + h / 2;
    lineStyle.alignment === 0 && context.save(), context.beginPath(), context.moveTo(x, ym), context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y), context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym), context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye), context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym), context.closePath(), lineStyle.alignment === 0 && context.clip(), fillStyle.visible && (context.globalAlpha = fillStyle.alpha * worldAlpha, context.fillStyle = contextFillStyle, context.fill()), lineStyle.alignment === 0 && context.restore();
  }
  /**
   * Paint Rounded Rectangle
   * @private
   * @param shape - Shape to be drawn
   * @param fillStyle - Fill for the shape
   * @param lineStyle - Line style for the shape
   * @param contextFillStyle - The canvas context fill style
   * @param worldAlpha - The multiplied alpha of the displayObject
   * @param context - The canvas context
   */
  paintRoundedRectangle(shape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context) {
    const rx = shape.x, ry = shape.y, width = shape.width, height = shape.height;
    let radius = shape.radius;
    const maxRadius = Math.min(width, height) / 2;
    radius = radius > maxRadius ? maxRadius : radius, lineStyle.alignment === 0 && context.save(), context.beginPath(), context.moveTo(rx, ry + radius), context.lineTo(rx, ry + height - radius), context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height), context.lineTo(rx + width - radius, ry + height), context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius), context.lineTo(rx + width, ry + radius), context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry), context.lineTo(rx + radius, ry), context.quadraticCurveTo(rx, ry, rx, ry + radius), context.closePath(), lineStyle.alignment === 0 && context.clip(), fillStyle.visible && (context.globalAlpha = fillStyle.alpha * worldAlpha, context.fillStyle = contextFillStyle, context.fill()), lineStyle.alignment === 0 && context.restore();
  }
  setPatternTransform(pattern, matrix) {
    if (this._svgMatrix !== !1) {
      if (!this._svgMatrix) {
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        if (svg?.createSVGMatrix && (this._svgMatrix = svg.createSVGMatrix()), !this._svgMatrix || !pattern.setTransform) {
          this._svgMatrix = !1;
          return;
        }
      }
      this._svgMatrix.a = matrix.a, this._svgMatrix.b = matrix.b, this._svgMatrix.c = matrix.c, this._svgMatrix.d = matrix.d, this._svgMatrix.e = matrix.tx, this._svgMatrix.f = matrix.ty, pattern.setTransform(this._svgMatrix.inverse());
    }
  }
  /** destroy graphics object */
  destroy() {
    this.renderer = null, this._svgMatrix = null, this._tempMatrix = null;
  }
}
CanvasGraphicsRenderer.extension = {
  name: "graphics",
  type: ExtensionType.CanvasRendererPlugin
};
extensions.add(CanvasGraphicsRenderer);
export {
  CanvasGraphicsRenderer
};
//# sourceMappingURL=CanvasGraphicsRenderer.mjs.map
