{"version":3,"file":"CanvasGraphicsRenderer.mjs","sources":["../src/CanvasGraphicsRenderer.ts"],"sourcesContent":["import { canvasUtils } from '@pixi/canvas-renderer';\nimport { Color, extensions, ExtensionType, Matrix, SHAPES, Texture } from '@pixi/core';\nimport { PolygonUtils } from './utils/PolygonUtils';\n\nimport type { CanvasRenderer, CrossPlatformCanvasRenderingContext2D } from '@pixi/canvas-renderer';\nimport type { Circle, Ellipse, ExtensionMetadata, Polygon, Rectangle, RoundedRectangle } from '@pixi/core';\nimport type { FillStyle, Graphics, GraphicsData, LineStyle } from '@pixi/graphics';\n\n/*\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original PixiJS version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they\n * now share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's CanvasGraphicsRenderer:\n * https://github.com/libgdx/libgdx/blob/1.0.0/gdx/src/com/badlogic/gdx/graphics/glutils/ShapeRenderer.java\n */\n\n/**\n * Renderer dedicated to drawing and batching graphics objects.\n * @class\n * @protected\n * @memberof PIXI\n */\nexport class CanvasGraphicsRenderer\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        name: 'graphics',\n        type: ExtensionType.CanvasRendererPlugin,\n    };\n\n    /** A reference to the current renderer */\n    public renderer: CanvasRenderer;\n    private _svgMatrix: DOMMatrix | boolean = null;\n    private _tempMatrix: Matrix = new Matrix();\n\n    /**\n     * @param renderer - A reference to the current renderer.\n     */\n    constructor(renderer: CanvasRenderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * calculates fill/stroke style for canvas\n     * @private\n     * @param style - A graphics {@link PIXI.FILL_STYLE} where if `texture` is specified then a tinted CanvasPattern\n     * will be used for the fill.stroke\n     * @param tint - color to set the fill/stroke too.\n     */\n    private _calcCanvasStyle(style: FillStyle, tint: number): string | CanvasPattern\n    {\n        let res;\n\n        if (style.texture && style.texture.baseTexture !== Texture.WHITE.baseTexture)\n        {\n            if (style.texture.valid)\n            {\n                res = canvasUtils.getTintedPattern(style.texture, tint);\n                this.setPatternTransform(res, style.matrix || Matrix.IDENTITY);\n            }\n            else\n            {\n                res = '#808080';\n            }\n        }\n        else\n        {\n            res = `#${(`00000${(tint | 0).toString(16)}`).slice(-6)}`;\n        }\n\n        return res;\n    }\n\n    /**\n     * Renders a Graphics object to a canvas.\n     * @param graphics - the actual graphics object to render\n     */\n    public render(graphics: Graphics): void\n    {\n        const renderer = this.renderer;\n\n        const context = renderer.canvasContext.activeContext;\n        const worldAlpha = graphics.worldAlpha;\n        const transform = graphics.transform.worldTransform;\n\n        renderer.canvasContext.setContextTransform(transform);\n        renderer.canvasContext.setBlendMode(graphics.blendMode);\n\n        const graphicsData = graphics.geometry.graphicsData;\n\n        let contextFillStyle;\n        let contextStrokeStyle;\n\n        const tint = Color.shared.setValue(graphics.tint).toArray();\n\n        for (let i = 0; i < graphicsData.length; i++)\n        {\n            const data = graphicsData[i];\n            const shape = data.shape;\n            const fillStyle = data.fillStyle;\n            const lineStyle = data.lineStyle;\n\n            const fillColor = data.fillStyle.color | 0;\n            const lineColor = data.lineStyle.color | 0;\n\n            if (data.matrix)\n            {\n                renderer.canvasContext.setContextTransform(transform.copyTo(this._tempMatrix).append(data.matrix));\n            }\n\n            if (fillStyle.visible)\n            {\n                contextFillStyle = this._calcCanvasStyle(fillStyle, Color.shared\n                    .setValue(fillColor)\n                    .multiply(tint)\n                    .toNumber()\n                );\n            }\n            if (lineStyle.visible)\n            {\n                contextStrokeStyle = this._calcCanvasStyle(lineStyle, Color.shared\n                    .setValue(lineColor)\n                    .multiply(tint)\n                    .toNumber()\n                );\n            }\n\n            context.lineWidth = lineStyle.width;\n            context.lineCap = lineStyle.cap;\n            context.lineJoin = lineStyle.join;\n            context.miterLimit = lineStyle.miterLimit;\n\n            if (data.type === SHAPES.POLY)\n            {\n                context.beginPath();\n\n                const tempShape = shape as Polygon;\n                let points = tempShape.points;\n                const holes = data.holes;\n                let outerArea;\n                let innerArea;\n                let px;\n                let py;\n                let holesDirection: boolean[];\n\n                context.moveTo(points[0], points[1]);\n\n                for (let j = 2; j < points.length; j += 2)\n                {\n                    context.lineTo(points[j], points[j + 1]);\n                }\n\n                if (tempShape.closeStroke)\n                {\n                    context.closePath();\n                }\n\n                if (holes.length > 0)\n                {\n                    holesDirection = [];\n                    outerArea = 0;\n                    px = points[0];\n                    py = points[1];\n                    for (let j = 2; j + 2 < points.length; j += 2)\n                    {\n                        outerArea += ((points[j] - px) * (points[j + 3] - py))\n                            - ((points[j + 2] - px) * (points[j + 1] - py));\n                    }\n\n                    for (let k = 0; k < holes.length; k++)\n                    {\n                        points = (holes[k].shape as Polygon).points;\n\n                        if (!points)\n                        {\n                            continue;\n                        }\n\n                        innerArea = 0;\n                        px = points[0];\n                        py = points[1];\n                        for (let j = 2; j + 2 < points.length; j += 2)\n                        {\n                            innerArea += ((points[j] - px) * (points[j + 3] - py))\n                                - ((points[j + 2] - px) * (points[j + 1] - py));\n                        }\n\n                        if (innerArea * outerArea < 0)\n                        {\n                            context.moveTo(points[0], points[1]);\n\n                            for (let j = 2; j < points.length; j += 2)\n                            {\n                                context.lineTo(points[j], points[j + 1]);\n                            }\n                        }\n                        else\n                        {\n                            context.moveTo(points[points.length - 2], points[points.length - 1]);\n\n                            for (let j = points.length - 4; j >= 0; j -= 2)\n                            {\n                                context.lineTo(points[j], points[j + 1]);\n                            }\n                        }\n\n                        if ((holes[k].shape as Polygon).closeStroke)\n                        {\n                            context.closePath();\n                        }\n\n                        holesDirection[k] = innerArea * outerArea < 0;\n                    }\n                }\n\n                if (fillStyle.visible)\n                {\n                    context.globalAlpha = fillStyle.alpha * worldAlpha;\n                    context.fillStyle = contextFillStyle;\n                    context.fill();\n                }\n\n                if (lineStyle.visible)\n                {\n                    this.paintPolygonStroke(\n                        tempShape, lineStyle, contextStrokeStyle, holes, holesDirection, worldAlpha, context\n                    );\n                }\n            }\n            else if (data.type === SHAPES.RECT)\n            {\n                const tempShape = shape as Rectangle;\n\n                if (fillStyle.visible)\n                {\n                    context.globalAlpha = fillStyle.alpha * worldAlpha;\n                    context.fillStyle = contextFillStyle;\n                    context.fillRect(tempShape.x, tempShape.y, tempShape.width, tempShape.height);\n                }\n\n                if (lineStyle.visible)\n                {\n                    const alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));\n                    const width = tempShape.width + (2 * alignmentOffset);\n                    const height = tempShape.height + (2 * alignmentOffset);\n\n                    context.globalAlpha = lineStyle.alpha * worldAlpha;\n                    context.strokeStyle = contextStrokeStyle;\n                    context.strokeRect(tempShape.x - alignmentOffset, tempShape.y - alignmentOffset, width, height);\n                }\n            }\n            else if (data.type === SHAPES.CIRC)\n            {\n                const tempShape = shape as Circle;\n\n                // TODO - need to be Undefined!\n                context.beginPath();\n                context.arc(tempShape.x, tempShape.y, tempShape.radius, 0, 2 * Math.PI);\n                context.closePath();\n\n                if (fillStyle.visible)\n                {\n                    context.globalAlpha = fillStyle.alpha * worldAlpha;\n                    context.fillStyle = contextFillStyle;\n                    context.fill();\n                }\n\n                if (lineStyle.visible)\n                {\n                    if (lineStyle.alignment !== 0.5)\n                    {\n                        const alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));\n\n                        context.beginPath();\n                        context.arc(tempShape.x, tempShape.y, tempShape.radius + alignmentOffset, 0, 2 * Math.PI);\n                        context.closePath();\n                    }\n\n                    context.globalAlpha = lineStyle.alpha * worldAlpha;\n                    context.strokeStyle = contextStrokeStyle;\n                    context.stroke();\n                }\n            }\n            else if (data.type === SHAPES.ELIP)\n            {\n                const tempShape = shape as Ellipse;\n                const drawShapeOverStroke = lineStyle.alignment === 1;\n\n                if (!drawShapeOverStroke)\n                {\n                    this.paintEllipse(tempShape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context);\n                }\n\n                if (lineStyle.visible)\n                {\n                    if (lineStyle.alignment !== 0.5)\n                    {\n                        const kappa = 0.5522848;\n                        const alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));\n                        const sW = (tempShape.width + alignmentOffset) * 2;\n                        const sH = (tempShape.height + alignmentOffset) * 2;\n                        const sX = tempShape.x - (sW / 2);\n                        const sY = tempShape.y - (sH / 2);\n                        const sOx = (sW / 2) * kappa;\n                        const sOy = (sH / 2) * kappa;\n                        const sXe = sX + sW;\n                        const sYe = sY + sH;\n                        const sXm = sX + (sW / 2);\n                        const sYm = sY + (sH / 2);\n\n                        context.beginPath();\n                        context.moveTo(sX, sYm);\n                        context.bezierCurveTo(sX, sYm - sOy, sXm - sOx, sY, sXm, sY);\n                        context.bezierCurveTo(sXm + sOx, sY, sXe, sYm - sOy, sXe, sYm);\n                        context.bezierCurveTo(sXe, sYm + sOy, sXm + sOx, sYe, sXm, sYe);\n                        context.bezierCurveTo(sXm - sOx, sYe, sX, sYm + sOy, sX, sYm);\n                        context.closePath();\n                    }\n\n                    context.globalAlpha = lineStyle.alpha * worldAlpha;\n                    context.strokeStyle = contextStrokeStyle;\n                    context.stroke();\n                }\n\n                if (drawShapeOverStroke)\n                {\n                    this.paintEllipse(tempShape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context);\n                }\n            }\n            else if (data.type === SHAPES.RREC)\n            {\n                const tempShape = shape as RoundedRectangle;\n                const drawShapeOverStroke = lineStyle.alignment === 1;\n\n                if (!drawShapeOverStroke)\n                {\n                    this.paintRoundedRectangle(tempShape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context);\n                }\n\n                if (lineStyle.visible)\n                {\n                    if (lineStyle.alignment !== 0.5)\n                    {\n                        const width = tempShape.width;\n                        const height = tempShape.height;\n                        const alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));\n                        const sRx = tempShape.x - alignmentOffset;\n                        const sRy = tempShape.y - alignmentOffset;\n                        const sWidth = tempShape.width + (2 * alignmentOffset);\n                        const sHeight = tempShape.height + (2 * alignmentOffset);\n                        const radiusOffset = alignmentOffset * (lineStyle.alignment >= 1\n                            ? Math.min(sWidth / width, sHeight / height) : Math.min(width / sWidth, height / sHeight));\n                        let sRadius = tempShape.radius + radiusOffset;\n                        const sMaxRadius = Math.min(sWidth, sHeight) / 2;\n\n                        sRadius = sRadius > sMaxRadius ? sMaxRadius : sRadius;\n\n                        context.beginPath();\n                        context.moveTo(sRx, sRy + sRadius);\n                        context.lineTo(sRx, sRy + sHeight - sRadius);\n                        context.quadraticCurveTo(sRx, sRy + sHeight, sRx + sRadius, sRy + sHeight);\n                        context.lineTo(sRx + sWidth - sRadius, sRy + sHeight);\n                        context.quadraticCurveTo(sRx + sWidth, sRy + sHeight, sRx + sWidth, sRy + sHeight - sRadius);\n                        context.lineTo(sRx + sWidth, sRy + sRadius);\n                        context.quadraticCurveTo(sRx + sWidth, sRy, sRx + sWidth - sRadius, sRy);\n                        context.lineTo(sRx + sRadius, sRy);\n                        context.quadraticCurveTo(sRx, sRy, sRx, sRy + sRadius);\n                        context.closePath();\n                    }\n\n                    context.globalAlpha = lineStyle.alpha * worldAlpha;\n                    context.strokeStyle = contextStrokeStyle;\n                    context.stroke();\n                }\n\n                if (drawShapeOverStroke)\n                {\n                    this.paintRoundedRectangle(tempShape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context);\n                }\n            }\n        }\n    }\n\n    /**\n     * Paint stroke for polygon and holes\n     * @private\n     * @param shape - Shape to be drawn\n     * @param lineStyle - Line style for the shape\n     * @param contextStrokeStyle - The strokeStyle for the canvas context\n     * @param holes - Holes to be added to the shape\n     * @param holesDirection -\n     * @param worldAlpha - The multiplied alpha of the displayObject\n     * @param context - The canvas context\n     */\n    private paintPolygonStroke(\n        shape: Polygon, lineStyle: LineStyle, contextStrokeStyle: string | CanvasPattern,\n        holes: GraphicsData[], holesDirection: boolean[],\n        worldAlpha: number, context: CrossPlatformCanvasRenderingContext2D\n    ): void\n    {\n        if (lineStyle.alignment !== 0.5)\n        {\n            const alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));\n            let offsetPoints = PolygonUtils.offsetPolygon(shape.points, alignmentOffset);\n            let points;\n\n            context.beginPath();\n            context.moveTo(offsetPoints[0], offsetPoints[1]);\n\n            for (let j = 2; j < offsetPoints.length; j += 2)\n            {\n                context.lineTo(offsetPoints[j], offsetPoints[j + 1]);\n            }\n\n            if (shape.closeStroke)\n            {\n                context.closePath();\n            }\n\n            for (let k = 0; k < holes.length; k++)\n            {\n                points = (holes[k].shape as Polygon).points;\n                offsetPoints = PolygonUtils.offsetPolygon(points, alignmentOffset);\n\n                if (holesDirection[k])\n                {\n                    context.moveTo(offsetPoints[0], offsetPoints[1]);\n\n                    for (let j = 2; j < offsetPoints.length; j += 2)\n                    {\n                        context.lineTo(offsetPoints[j], offsetPoints[j + 1]);\n                    }\n                }\n                else\n                {\n                    context.moveTo(offsetPoints[offsetPoints.length - 2], offsetPoints[offsetPoints.length - 1]);\n\n                    for (let j = offsetPoints.length - 4; j >= 0; j -= 2)\n                    {\n                        context.lineTo(offsetPoints[j], offsetPoints[j + 1]);\n                    }\n                }\n\n                if ((holes[k].shape as Polygon).closeStroke)\n                {\n                    context.closePath();\n                }\n            }\n        }\n\n        context.globalAlpha = lineStyle.alpha * worldAlpha;\n        context.strokeStyle = contextStrokeStyle;\n        context.stroke();\n    }\n\n    /**\n     * Paint Ellipse\n     * @private\n     * @param shape - Shape to be drawn\n     * @param fillStyle - Fill for the shape\n     * @param lineStyle - Line style for the shape\n     * @param contextFillStyle - The canvas context fill style\n     * @param worldAlpha - The multiplied alpha of the displayObject\n     * @param context - The canvas context\n     */\n    private paintEllipse(\n        shape: Ellipse, fillStyle: FillStyle, lineStyle: LineStyle,\n        contextFillStyle: string | CanvasPattern, worldAlpha: number,\n        context: CrossPlatformCanvasRenderingContext2D): void\n    {\n        // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas\n        const w = shape.width * 2;\n        const h = shape.height * 2;\n\n        const x = shape.x - (w / 2);\n        const y = shape.y - (h / 2);\n\n        const kappa = 0.5522848;\n        const ox = (w / 2) * kappa; // control point offset horizontal\n        const oy = (h / 2) * kappa; // control point offset vertical\n        const xe = x + w; // x-end\n        const ye = y + h; // y-end\n        const xm = x + (w / 2); // x-middle\n        const ym = y + (h / 2); // y-middle\n\n        if (lineStyle.alignment === 0)\n        {\n            context.save();\n        }\n\n        context.beginPath();\n        context.moveTo(x, ym);\n        context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n        context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n        context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n        context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n        context.closePath();\n\n        if (lineStyle.alignment === 0)\n        {\n            context.clip();\n        }\n\n        if (fillStyle.visible)\n        {\n            context.globalAlpha = fillStyle.alpha * worldAlpha;\n            context.fillStyle = contextFillStyle;\n            context.fill();\n        }\n\n        if (lineStyle.alignment === 0)\n        {\n            context.restore();\n        }\n    }\n\n    /**\n     * Paint Rounded Rectangle\n     * @private\n     * @param shape - Shape to be drawn\n     * @param fillStyle - Fill for the shape\n     * @param lineStyle - Line style for the shape\n     * @param contextFillStyle - The canvas context fill style\n     * @param worldAlpha - The multiplied alpha of the displayObject\n     * @param context - The canvas context\n     */\n    private paintRoundedRectangle(\n        shape: RoundedRectangle, fillStyle: FillStyle, lineStyle: LineStyle,\n        contextFillStyle: string | CanvasPattern, worldAlpha: number,\n        context: CrossPlatformCanvasRenderingContext2D\n    ): void\n    {\n        const rx = shape.x;\n        const ry = shape.y;\n        const width = shape.width;\n        const height = shape.height;\n        let radius = shape.radius;\n\n        const maxRadius = Math.min(width, height) / 2;\n\n        radius = radius > maxRadius ? maxRadius : radius;\n\n        if (lineStyle.alignment === 0)\n        {\n            context.save();\n        }\n\n        context.beginPath();\n        context.moveTo(rx, ry + radius);\n        context.lineTo(rx, ry + height - radius);\n        context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);\n        context.lineTo(rx + width - radius, ry + height);\n        context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);\n        context.lineTo(rx + width, ry + radius);\n        context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);\n        context.lineTo(rx + radius, ry);\n        context.quadraticCurveTo(rx, ry, rx, ry + radius);\n        context.closePath();\n\n        if (lineStyle.alignment === 0)\n        {\n            context.clip();\n        }\n\n        if (fillStyle.visible)\n        {\n            context.globalAlpha = fillStyle.alpha * worldAlpha;\n            context.fillStyle = contextFillStyle;\n            context.fill();\n        }\n\n        if (lineStyle.alignment === 0)\n        {\n            context.restore();\n        }\n    }\n\n    public setPatternTransform(pattern: CanvasPattern, matrix: Matrix): void\n    {\n        if (this._svgMatrix === false)\n        {\n            return;\n        }\n        if (!this._svgMatrix)\n        {\n            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n\n            if (svg?.createSVGMatrix)\n            {\n                this._svgMatrix = svg.createSVGMatrix();\n            }\n            if (!this._svgMatrix || !pattern.setTransform)\n            {\n                this._svgMatrix = false;\n\n                return;\n            }\n        }\n\n        (this._svgMatrix as DOMMatrix).a = matrix.a;\n        (this._svgMatrix as DOMMatrix).b = matrix.b;\n        (this._svgMatrix as DOMMatrix).c = matrix.c;\n        (this._svgMatrix as DOMMatrix).d = matrix.d;\n        (this._svgMatrix as DOMMatrix).e = matrix.tx;\n        (this._svgMatrix as DOMMatrix).f = matrix.ty;\n        pattern.setTransform((this._svgMatrix as DOMMatrix).inverse());\n    }\n\n    /** destroy graphics object */\n    public destroy(): void\n    {\n        this.renderer = null;\n        this._svgMatrix = null;\n        this._tempMatrix = null;\n    }\n}\n\nextensions.add(CanvasGraphicsRenderer);\n"],"names":[],"mappings":"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"}