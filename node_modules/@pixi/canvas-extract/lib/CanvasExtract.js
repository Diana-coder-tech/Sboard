"use strict";
var core = require("@pixi/core");
const TEMP_RECT = new core.Rectangle();
class CanvasExtract {
  /**
   * @param renderer - A reference to the current renderer
   */
  constructor(renderer) {
    this.renderer = renderer;
  }
  /**
   * Will return a HTML Image of the target
   * @param target - A displayObject or renderTexture
   *  to convert. If left empty will use the main renderer
   * @param format - Image format, e.g. "image/jpeg" or "image/webp".
   * @param quality - JPEG or Webp compression from 0 to 1. Default is 0.92.
   * @param frame - The frame the extraction is restricted to.
   * @returns HTML Image of the target
   */
  async image(target, format, quality, frame) {
    const image = new Image();
    return image.src = await this.base64(target, format, quality, frame), image;
  }
  /**
   * Will return a base64 encoded string of this target. It works by calling
   *  `CanvasExtract.getCanvas` and then running toDataURL on that.
   * @param target - A displayObject or renderTexture
   *  to convert. If left empty will use the main renderer
   * @param format - Image format, e.g. "image/jpeg" or "image/webp".
   * @param quality - JPEG or Webp compression from 0 to 1. Default is 0.92.
   * @param frame - The frame the extraction is restricted to.
   * @returns A base64 encoded string of the texture.
   */
  async base64(target, format, quality, frame) {
    const canvas = this.canvas(target, frame);
    if (canvas.toBlob !== void 0)
      return new Promise((resolve, reject) => {
        canvas.toBlob((blob) => {
          if (!blob) {
            reject(new Error("ICanvas.toBlob failed!"));
            return;
          }
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result), reader.onerror = reject, reader.readAsDataURL(blob);
        }, format, quality);
      });
    if (canvas.toDataURL !== void 0)
      return canvas.toDataURL(format, quality);
    if (canvas.convertToBlob !== void 0) {
      const blob = await canvas.convertToBlob({ type: format, quality });
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result), reader.onerror = reject, reader.readAsDataURL(blob);
      });
    }
    throw new Error("CanvasExtract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");
  }
  /**
   * Creates a Canvas element, renders this target to it and then returns it.
   * @param target - A displayObject or renderTexture
   *  to convert. If left empty will use the main renderer
   * @param frame - The frame the extraction is restricted to.
   * @returns A Canvas element with the texture rendered on.
   */
  canvas(target, frame) {
    const renderer = this.renderer;
    if (!renderer)
      throw new Error("The CanvasExtract has already been destroyed");
    let context, resolution, renderTexture;
    target && (target instanceof core.RenderTexture ? renderTexture = target : (renderTexture = renderer.generateTexture(target, {
      region: frame,
      resolution: renderer.resolution
    }), frame && (TEMP_RECT.width = frame.width, TEMP_RECT.height = frame.height, frame = TEMP_RECT))), renderTexture ? (context = renderTexture.baseTexture._canvasRenderTarget.context, resolution = renderTexture.baseTexture._canvasRenderTarget.resolution, frame = frame ?? renderTexture.frame) : (context = renderer.canvasContext.rootContext, resolution = renderer._view.resolution, frame || (frame = TEMP_RECT, frame.width = renderer.width / resolution, frame.height = renderer.height / resolution));
    const x = Math.round(frame.x * resolution), y = Math.round(frame.y * resolution), width = Math.max(Math.round(frame.width * resolution), 1), height = Math.max(Math.round(frame.height * resolution), 1), canvasBuffer = new core.utils.CanvasRenderTarget(width, height, 1), canvasData = context.getImageData(x, y, width, height);
    return canvasBuffer.context.putImageData(canvasData, 0, 0), canvasBuffer.canvas;
  }
  /**
   * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA
   * order, with integer values between 0 and 255 (included).
   * @param target - A displayObject or renderTexture
   *  to convert. If left empty will use the main renderer
   * @param frame - The frame the extraction is restricted to.
   * @returns One-dimensional array containing the pixel data of the entire texture
   */
  pixels(target, frame) {
    const renderer = this.renderer;
    if (!renderer)
      throw new Error("The CanvasExtract has already been destroyed");
    let context, resolution, renderTexture;
    target && (target instanceof core.RenderTexture ? renderTexture = target : (renderTexture = renderer.generateTexture(target, {
      region: frame,
      resolution: renderer.resolution
    }), frame && (TEMP_RECT.width = frame.width, TEMP_RECT.height = frame.height, frame = TEMP_RECT))), renderTexture ? (context = renderTexture.baseTexture._canvasRenderTarget.context, resolution = renderTexture.baseTexture._canvasRenderTarget.resolution, frame = frame ?? renderTexture.frame) : (context = renderer.canvasContext.rootContext, resolution = renderer.resolution, frame || (frame = TEMP_RECT, frame.width = renderer.width / resolution, frame.height = renderer.height / resolution));
    const x = Math.round(frame.x * resolution), y = Math.round(frame.y * resolution), width = Math.max(Math.round(frame.width * resolution), 1), height = Math.max(Math.round(frame.height * resolution), 1);
    return context.getImageData(x, y, width, height).data;
  }
  /** Destroys the extract */
  destroy() {
    this.renderer = null;
  }
}
CanvasExtract.extension = {
  name: "extract",
  type: core.ExtensionType.CanvasRendererSystem
};
core.extensions.add(CanvasExtract);
exports.CanvasExtract = CanvasExtract;
//# sourceMappingURL=CanvasExtract.js.map
